# -*- coding: utf-8 -*-
"""GlucoSyncAndroid.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Bwy6yvCjoyOJMnFFA4Tnhzl7Y1jQkWMt
"""

import pandas as pd
import os
from sklearn.tree import DecisionTreeClassifier
from sklearn.feature_extraction.text import CountVectorizer
import tensorflow as tf
from pathlib import Path
from ml_service.settings import BASE_DIR
#from tensorflow import lite
#import joblib

file_path = os.path.join(BASE_DIR.parent, 'data_input.csv')

# Load data_input.csv file
df = pd.read_csv(file_path)


print(file_path)



def train_decision_tree(diabetic_level_range):
    # Filter data for the specified diabetic level range
    df_filtered = df[df['diabetic'].between(*diabetic_level_range)]

    # Assuming 'diabetic_level' is the target variable
    X_text = (df_filtered['meal'].fillna('') + ' ' + df_filtered['exercise'].fillna('')).astype(str)
    y = df_filtered['diabetic']

    # Use CountVectorizer for text vectorization
    vectorizer = CountVectorizer()
    X = vectorizer.fit_transform(X_text)

    # Create and train the Decision Tree Classifier
    classifier = DecisionTreeClassifier()
    classifier.fit(X, y)

    return classifier, vectorizer

def get_recommendations(diabetic_level, diabetic_level_range):
    # Check if the provided diabetic level is within the specified range
    if diabetic_level not in range(*diabetic_level_range):
        if diabetic_level > 200:
            return "Your diabetic level is very high. Please consult with a doctor."
        elif diabetic_level < 70:
            return "You are not a diabetic person. Chill!"
        else:
            return "Invalid diabetic level. Please provide a level within the specified range."

    # Filter the rows based on the provided diabetic level
    recommendations = df[df['diabetic'] == diabetic_level]

    if recommendations.empty:
        # Train the model using the specified diabetic level range
        classifier, vectorizer = train_decision_tree(diabetic_level_range)

        # Create a sample input for prediction (modify as needed)
        sample_input_text = 'sample_meal sample_exercise'
        sample_input_vectorized = vectorizer.transform([sample_input_text])

        # Make a prediction for the user's diabetic level
        predicted_diabetic_level = classifier.predict(sample_input_vectorized)[0]

        # Filter the recommendations based on the predicted diabetic level
        recommendations = df[df['diabetic'] == predicted_diabetic_level]

    if recommendations.empty:
        return "No recommendations found for the specified diabetic level."

    # Extract meal and exercise recommendations
    meal_recommendations = recommendations['meal'].values[0].split(', ')
    exercise_recommendations = recommendations['exercise'].values[0].split(', ')

    # Format the result into JSON
    formatted_result = {
        'meal': format_recommendations(meal_recommendations),
        'exercise': format_recommendations(exercise_recommendations)
    }

    return formatted_result

def format_recommendations(recommendations):
    formatted_dict = {'morning': [], 'afternoon': [], 'evening': []}

    for recommendation in recommendations:
        parts = recommendation.split(': ')
        if len(parts) == 2:
            time, name = parts
            formatted_dict[time.lower()].append({'name': name.strip()})

    return formatted_dict


# Specify the diabetic level range for training
training_diabetic_level_range = (70, 201)


# Test for diabetic level 70
# i want to pass the input (user_diabetic_level) from the android user
user_diabetic_level = 108
result = get_recommendations(user_diabetic_level, training_diabetic_level_range)
result


# convert .ipynb to .tflite (its working fine)

# import tensorflow as tf
# from tensorflow.keras.models import Sequential
# from tensorflow.keras.layers import Dense

# # Create a simple Keras model for demonstration purposes
# model = Sequential()
# model.add(Dense(units=64, activation='relu', input_dim=100))
# model.add(Dense(units=1, activation='sigmoid'))

# # Compile the model
# model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# # Train the model (replace this with your actual training data)
# # model.fit(x_train, y_train, epochs=5, batch_size=32)

# # Save the Keras model to an HDF5 file
# model.save("keras_model.keras")

# # Convert the Keras model to TensorFlow Lite
# converter = tf.lite.TFLiteConverter.from_keras_model(model)
# tflite_model = converter.convert()

# # Save the TensorFlow Lite model to a file
# with open('model.tflite', 'wb') as f:
#     f.write(tflite_model)

# import tensorflow as tf
# from tensorflow.keras.models import Sequential

# # Assuming 'model' is your trained model
# model = Sequential()
# # ... build your model ...

# # Save the model in SavedModel format
# model.save('/content/saved_model/')

# # Convert the SavedModel to TensorFlow Lite
# converter = tf.lite.TFLiteConverter.from_saved_model("saved_model")
# tflite_model = converter.convert()

# # Save the TensorFlow Lite model to a file
# with open('model.tflite', 'wb') as f:
#     f.write(tflite_model)



# convert .ipynb model to .tflite

# Load the saved model
# model = tf.keras.models.load_model('/content/saved_model/')

# # Convert the model to TensorFlow Lite
# converter = tf.lite.TFLiteConverter.from_keras_model(model)
# tflite_model = converter.convert()

# # Save the TensorFlow Lite model to a file
# with open("model.tflite", "wb") as f:
#     f.write(tflite_model)

#  #Save the model in SavedModel format
# model.save('/content/saved_model/')

# converter = tf.lite.TFLiteConverter.from_saved_model('/content/saved_model/')
# tflite_model = converter.convert()

# # Save the TensorFlow Lite model
# with open('/content/model.tflite', 'wb') as f:
#     f.write(tflite_model)

# import tensorflow as tf
# from tensorflow.keras.models import Sequential
# model = Sequential()

# from tensorboard import lite
# converter = lite.TFLiteConverter.from_keras_model(model)

# tfmodel = converter.convert()
# open('GlucoSyncAndroid.tflite', 'wb').write(tfmodel)



#model.add(Dense(64))


# import tensorflow as tf

# # Convert the model
# converter = tf.lite.TFLiteConverter.from_saved_model('/content/sample_data.pb') # path to the SavedModel directory
# tflite_model = converter.convert()

# # Save the model.
# with open('model.tflite', 'wb') as f:
#   f.write(tflite_model)


# import tensorflow as tf

# # Load your Keras model
# model = tf.keras.models.load_model('GlucoSyncAndroid.h5')

# # Convert the model to TensorFlow Lite format
# converter = tf.lite.TFLiteConverter.from_keras_model(model)
# tflite_model = converter.convert()

# # Save the TensorFlow Lite model to a file
# with open('GlucoSyncAndroid.tflite', 'wb') as f:
#     f.write(tflite_model)

# import pandas as pd
# from sklearn.tree import DecisionTreeClassifier
# from sklearn.feature_extraction.text import CountVectorizer
# import joblib
# import tensorflow as tf

# # Load data_input.csv file
# df = pd.read_csv('data_input.csv')

# def train_decision_tree(diabetic_level_range):
#     # Filter data for the specified diabetic level range
#     df_filtered = df[df['diabetic'].between(*diabetic_level_range)]

#     # Assuming 'diabetic_level' is the target variable
#     X_text = (df_filtered['meal'].fillna('') + ' ' + df_filtered['exercise'].fillna('')).astype(str)
#     y = df_filtered['diabetic']

#     # Use CountVectorizer for text vectorization
#     vectorizer = CountVectorizer()
#     X = vectorizer.fit_transform(X_text)

#     # Create and train the Decision Tree Classifier
#     classifier = DecisionTreeClassifier()
#     classifier.fit(X, y)

#     # Save the model using joblib
#     joblib.dump(classifier, 'decision_tree_model.joblib')
#     joblib.dump(vectorizer, 'count_vectorizer.joblib')

#     return classifier, vectorizer

# # Train the model
# training_diabetic_level_range = (70, 201)
# classifier, vectorizer = train_decision_tree(training_diabetic_level_range)

# # Convert the model to TensorFlow Lite
# def convert_to_tflite(classifier, vectorizer):
#     # Create a sample input for inference (modify as needed)
#     sample_input_text = 'sample_meal sample_exercise'
#     sample_input_vectorized = vectorizer.transform([sample_input_text])

#     # Convert to TensorFlow Lite
#     converter = tf.lite.TFLiteConverter.from_sklearn(model=classifier, input_arrays=['input'], output_arrays=['output'])
#     tflite_model = converter.convert()

#     # Save the TensorFlow Lite model to a file
#     with open('model.tflite', 'wb') as f:
#         f.write(tflite_model)

# # Convert the model to TensorFlow Lite
# convert_to_tflite(classifier, vectorizer)

# !pip install tf2onnx

# import tf2onnx

# # Load the ONNX model
# onnx_model = tf2onnx.load("model.onnx")

# # Convert the ONNX model to TensorFlow Lite model
# tflite_model = tf2onnx.convert.from_onnx(onnx_model, opset=13)  # Specify the opset version

# # Save the TensorFlow Lite model to a file
# with open('model.tflite', 'wb') as f:
#     f.write(tflite_model)

# import tensorflow as tf
# import joblib

# # Load the trained model and vectorizer
# classifier = joblib.load('decision_tree_model.joblib')
# vectorizer = joblib.load('count_vectorizer.joblib')

# # Create a sample input for inference (modify as needed)
# sample_input_text = 'sample_meal sample_exercise'
# sample_input_vectorized = vectorizer.transform([sample_input_text])

# # Convert the model to TensorFlow Lite format
# converter = tf.lite.TFLiteConverter.from_sklearn(model=classifier, input_arrays=['input'], output_arrays=['output'])
# tflite_model = converter.convert()

# # Save the TensorFlow Lite model to a file
# with open('model.tflite', 'wb') as f:
#     f.write(tflite_model)

# import pandas as pd
# from sklearn.tree import DecisionTreeClassifier
# from sklearn.feature_extraction.text import CountVectorizer
# import tensorflow as tf
# import joblib

# # Load data_input.csv file
# df = pd.read_csv('data_input.csv')

# def train_decision_tree(diabetic_level_range):
#     # Filter data for the specified diabetic level range
#     df_filtered = df[df['diabetic'].between(*diabetic_level_range)]

#     # Assuming 'diabetic_level' is the target variable
#     X_text = (df_filtered['meal'].fillna('') + ' ' + df_filtered['exercise'].fillna('')).astype(str)
#     y = df_filtered['diabetic']

#     # Use CountVectorizer for text vectorization
#     vectorizer = CountVectorizer()
#     X = vectorizer.fit_transform(X_text)

#     # Create and train the Decision Tree Classifier
#     classifier = DecisionTreeClassifier()
#     classifier.fit(X, y)

#     # Save the model using joblib
#     joblib.dump(classifier, 'decision_tree_model.joblib')
#     joblib.dump(vectorizer, 'count_vectorizer.joblib')

#     return classifier, vectorizer

# # Train the model
# training_diabetic_level_range = (70, 201)
# classifier, vectorizer = train_decision_tree(training_diabetic_level_range)

# # Convert the model to TensorFlow Lite
# def convert_to_tflite(classifier, vectorizer):
#     # Create a sample input for inference (modify as needed)
#     sample_input_text = 'sample_meal sample_exercise'
#     sample_input_vectorized = vectorizer.transform([sample_input_text])

#     # Convert to TensorFlow Lite
#     converter = tf.lite.TFLiteConverter.from_sklearn(model=classifier, input_arrays=['input'], output_arrays=['output'])
#     tflite_model = converter.convert()

#     # Save the TensorFlow Lite model to a file
#     with open('model.tflite', 'wb') as f:
#         f.write(tflite_model)

# # Convert the model to TensorFlow Lite
# convert_to_tflite(classifier, vectorizer)